#!/usr/bin/env perl

use strict;
use warnings;
use FindBin;
use lib "$FindBin::RealBin/../lib";
use Getopt::Long;
use Fcntl qw(:DEFAULT :flock);
use Try::Tiny;
use Log::Log4perl;
use File::Find;
use Data::Dumper;
use Digest::MD5;
use JSON;
use Poppler;
use XML::LibXML;
use CIHM::Swift::Client;
use URI::Escape;
use DateTime::Format::ISO8601;
use HTTP::Date qw(:DEFAULT time2isoz);
use Data::Dumper;
use File::Path qw(make_path remove_tree);
use File::Spec;
use XML::LibXML;
use utf8;


{

    package restclient;

    use Moo;
    with 'Role::REST::Client';
}

Log::Log4perl->init_once("/etc/canadiana/tdr/log4perl.conf");
my $logger = Log::Log4perl::get_logger("CIHM::TDR");

sub log_warnings {
    my $warning = shift;
    chomp $warning;

    # Strip wide characters before  trying to log
    ( my $stripped = $warning ) =~ s/[^\x00-\x7f]//g;

    $logger->warn($stripped);
    print STDERR "$warning\n";
}
local $SIG{__WARN__} = sub { &log_warnings };

sub log_info {
    my $info = shift;
    chomp $info;

    # Strip wide characters before  trying to log
    ( my $stripped = $info ) =~ s/[^\x00-\x7f]//g;

    $logger->info($stripped);
    print "$info\n";
}

my $dmddir = '/crkn-nas-wip/_Metadata_Sychronised';
$dmddir = $ENV{syncdmd_dmddir} if ( exists $ENV{syncdmd_dmddir} );

my $lockfile = '/var/lock/tdr/syncdmd';
$lockfile = $ENV{syncdmd_lockfile} if ( exists $ENV{syncdmd_lockfile} );

$logger->info("Sync DMD");

my $swift_server;
$swift_server = $ENV{SWIFT_server} if ( exists $ENV{SWIFT_server} );

my $swift_user;
$swift_user = $ENV{SWIFT_user} if ( exists $ENV{SWIFT_user} );

my $swift_password;
$swift_password = $ENV{SWIFT_password} if ( exists $ENV{SWIFT_password} );

my $swift_account;
$swift_account = $ENV{SWIFT_account} if ( exists $ENV{SWIFT_account} );

my $swift_access_metadata;
$swift_access_metadata = $ENV{SWIFT_access_metadata}
  if ( exists $ENV{SWIFT_access_metadata} );

my $swift_preservation_files;
$swift_preservation_files = $ENV{SWIFT_preservation_files}
  if ( exists $ENV{SWIFT_preservation_files} );

my $retries = 3;

#Change order.  For running a second instance.
my $reverse;

# Limit for containeropt
my $limit = 10000;
GetOptions(
    'lockfile:s'                 => \$lockfile,
    'dmddir:s'                   => \$dmddir,
    'swift_server:s'             => \$swift_server,
    'swift_user:s'               => \$swift_user,
    'swift_password:s'           => \$swift_password,
    'swift_account:s'            => \$swift_account,
    'swift_access_metadata:s'    => \$swift_access_metadata,
    'swift_preservation_files:s' => \$swift_preservation_files,
    'retries:i'                  => \$retries,
    'reverse'                    => \$reverse,
    'limit:i'                    => \$limit
);

# Only allow one instance to run at a time..
sysopen( FH, $lockfile, O_WRONLY | O_CREAT )
  or die "can't open lockfile=$lockfile: $!\n";
flock( FH, LOCK_EX | LOCK_NB )
  or exit 0;

# Create both parent directories...
my $accessdir       = File::Spec->catfile( $dmddir, 'access' );
my $preservationdir = File::Spec->catfile( $dmddir, 'preservation' );

my @pathdir = make_path( $accessdir, $preservationdir );
die "Didn't create $accessdir\n"       if ( !-d $accessdir );
die "Didn't create $preservationdir\n" if ( !-d $preservationdir );

# Used to show a different processname during processing
my $syncdmdprog = $0;

my %swiftopt = (
    furl_options => { timeout => 3600 },

    server   => $swift_server,
    user     => $swift_user,
    password => $swift_password,
    account  => $swift_account,

);
my $swift = CIHM::Swift::Client->new(%swiftopt);

die "Missing `swift_access_metadata`" if !defined $swift_access_metadata;
my $test = $swift->container_head($swift_access_metadata);
if ( !$test || $test->code != 204 ) {
    die
"Problem connecting to Swift container:$swift_access_metadata . Check configuration\n";
}

die "Missing `swift_preservation_files`" if !defined $swift_preservation_files;
$test = $swift->container_head($swift_preservation_files);
if ( !$test || $test->code != 204 ) {
    die
"Problem connecting to Swift container:$swift_preservation_files . Check configuration\n";
}

my %containeropt = (
    delimiter => '/',
    limit     => $limit
);

$containeropt{'marker'} = 'oocihm.40185';

do {
    my %files;
    my $dataresp =
      $swift->container_get( $swift_preservation_files, \%containeropt );
    if ( $dataresp->code != 200 ) {
        die "container_get("
          . $swift_preservation_files
          . ") returned "
          . $dataresp->code . " - "
          . $dataresp->message . "\n";
    }

    undef $containeropt{'marker'};
    my $count = scalar( @{ $dataresp->content } );
    if ( $count && $count == $limit ) {
        if ( defined $dataresp->content->[ $count - 1 ]->{name} ) {
            $containeropt{'marker'} =
              $dataresp->content->[ $count - 1 ]->{name};
        }
        else {
            $containeropt{'marker'} =
              $dataresp->content->[ $count - 1 ]->{subdir};
        }
    }
    foreach my $object ( @{ $dataresp->content } ) {
        my $subdir = $object->{subdir};
        if ($subdir) {
            my $object = $subdir . "data/sip/data/metadata.xml";
            my $resp =
              $swift->object_head( $swift_preservation_files, $object );
            if ( $resp->code != 200 ) {
                die "object_head ("
                  . $swift_preservation_files . " , "
                  . $object
                  . ") returned "
                  . $resp->code . " - "
                  . $resp->message . "\n";
            }
            my $lastmodified = $resp->headers->header('last-modified');
            if ($lastmodified) {
                my $time  = str2time($lastmodified);
                my $aipid = $subdir;
                $aipid =~ s|/+||;

                # Check the time of the file on filesystem.
                # only GET if it is a different time
                getMETS( $aipid, $time, $object )

            }
        }
    }
} until ( !defined $containeropt{'marker'} );

sub getMETS {
    my ( $aipid, $time, $object ) = @_;

    $0 = $syncdmdprog . " getMETS $object";

    my $resp = $swift->object_get( $swift_preservation_files, $object );
    if ( $resp->code != 200 ) {
        die "object_get ("
          . $swift_preservation_files . " , "
          . $object
          . ") returned "
          . $resp->code . " - "
          . $resp->message . "\n";
    }

    my $xml = XML::LibXML->new->parse_string( $resp->content );
    my $xpc = XML::LibXML::XPathContext->new;
    $xpc->registerNs( 'mets',  "http://www.loc.gov/METS/" );
    $xpc->registerNs( 'xlink', "http://www.w3.org/1999/xlink" );

    my @nodes =
      $xpc->findnodes( "descendant::mets:structMap[\@TYPE=\"physical\"]",
        $xml );
    if ( scalar(@nodes) != 1 ) {
        die "Found " . scalar(@nodes) . " structMap(TYPE=physical)\n";
    }
    my @divs = $xpc->findnodes( 'descendant::mets:div', $nodes[0] );
    if (@divs) {
        my $div  = $divs[0];
        my $type = $div->getAttribute('TYPE');
        if (   ( $type ne 'document' )
            && ( $type ne 'issue' )
            && ( $type ne 'series' ) )
        {
            die
              "First DIV of METS isn't type=document|issue| , but type=$type\n";
        }
        my $dmdid = $div->getAttribute('DMDID');
        if ($dmdid) {
            my @dmdsec =
              $xpc->findnodes( "descendant::mets:dmdSec[\@ID=\"$dmdid\"]",
                $xml );
            if ( scalar(@dmdsec) != 1 ) {
                die "Found " . scalar(@dmdsec) . " dmdSec for ID=$dmdid\n";
            }
            my @md = $dmdsec[0]->nonBlankChildNodes();
            if ( scalar(@md) != 1 ) {
                die "Found " . scalar(@md) . " children for dmdSec ID=$dmdid\n";
            }
            my @types = split( /:/, $md[0]->nodeName );
            my $type = pop(@types);

            my $mdtype = $md[0]->getAttribute('MDTYPE');
            if ( $mdtype eq 'OTHER' ) {
                $mdtype = $md[0]->getAttribute('OTHERMDTYPE');
            }
            my @mdrecords = $md[0]->nonBlankChildNodes();
            my @records   = $mdrecords[0]->nonBlankChildNodes();
            my $xmlrecord = $records[0]->toString(0);

            storeDMD( $preservationdir, $aipid, $time, $mdtype, $xmlrecord )

        }
    }
    else {
        die "No DIVS in METS for $aipid\n";
    }

}

sub pathID {
    my ( $basepath, $id, $type ) = @_;

    # Create a full path based on ID
    my $idpath = $id;
    $idpath =~ s/\.[^\.]*$//;
    $idpath =~ s/\./\//g;

    my $path =
      File::Spec->catfile( $basepath, $idpath, $id . "-" . $type . ".xml" );
    return $path;

}

sub storeDMD {
    my ( $basepath, $id, $time, $type, $xml ) = @_;

    my $path = pathID( $basepath, $id, $type );

    my ( $volume, $directories, $file ) = File::Spec->splitpath($path);
    make_path($directories);

    $0 = $syncdmdprog . " storeDMD $file";

    open( my $fh, '>:encoding(UTF-8)', $path )
      or die "Could not open file '$path' $!";

    print $fh $xml;
    close $fh;

    my $atime = time;
    utime $atime, $time, $path;

    print "$path = " . time2isoz($time) . "\n";

}
